import { ZodError } from 'zod';

type ErrorContext = Record<string, unknown>;
declare abstract class BaseError<TContext extends ErrorContext = ErrorContext> extends Error {
    abstract readonly retry: boolean;
    readonly cause: BaseError | undefined;
    readonly context: TContext | undefined;
    abstract readonly name: string;
    constructor(opts: {
        message: string;
        cause?: BaseError;
        context?: TContext;
    });
    toString(): string;
}

type OkResult<V> = {
    val: V;
    err?: never;
};
type ErrResult<E extends BaseError> = {
    val?: never;
    err: E;
};
type Result<V, E extends BaseError = BaseError> = OkResult<V> | ErrResult<E>;
declare function Ok(): OkResult<never>;
declare function Ok<V>(val: V): OkResult<V>;
declare function Err<E extends BaseError>(err: E): ErrResult<E>;
/**
 * wrap catches thrown errors and returns a `Result`
 */
declare function wrap<T, E extends BaseError>(p: Promise<T>, errorFactory: (err: Error) => E): Promise<Result<T, E>>;

/**
 * Fetch Errors
 */
declare class FetchError extends BaseError<{
    url: string;
    method: string;
    [more: string]: unknown;
}> {
    readonly retry: boolean;
    readonly name: string;
    constructor(opts: {
        message: string;
        retry: boolean;
        cause?: BaseError;
        context?: {
            url: string;
            method: string;
            [more: string]: unknown;
        };
    });
}

/**
 * An object does not have the required schema.
 */
declare class SchemaError extends BaseError<{
    raw: unknown;
}> {
    readonly retry = false;
    readonly name: string;
    constructor(opts: {
        message: string;
        context?: {
            raw: unknown;
        };
        cause?: BaseError;
    });
    static fromZod<T>(e: ZodError<T>, raw: unknown, context?: Record<string, unknown>): SchemaError;
}

/**
 * Env Errors indicate an environment variable was not configured properly
 */
declare class EnvError extends BaseError<{
    name: string;
}> {
    readonly retry = false;
    readonly name: string;
}

export { BaseError, EnvError, Err, type ErrorContext, FetchError, Ok, type Result, SchemaError, wrap };
