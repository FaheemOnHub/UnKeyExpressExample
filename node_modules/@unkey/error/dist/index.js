'use strict';

// src/error-handling.ts
function Ok(val) {
  return { val };
}
function Err(err) {
  return { err };
}
async function wrap(p, errorFactory) {
  try {
    return Ok(await p);
  } catch (e) {
    return Err(errorFactory(e));
  }
}

// src/errors/base.ts
var BaseError = class extends Error {
  cause;
  context;
  constructor(opts) {
    super(opts.message);
    this.cause = opts.cause;
    this.context = opts.context;
  }
  toString() {
    return `${this.name}: ${this.message} - ${JSON.stringify(
      this.context
    )} - caused by ${this.cause?.toString()}`;
  }
};

// src/errors/fetch-error.ts
var FetchError = class _FetchError extends BaseError {
  retry;
  name = _FetchError.name;
  constructor(opts) {
    super(opts);
    this.retry = opts.retry;
  }
};

// src/errors/schema-error.ts
var SchemaError = class _SchemaError extends BaseError {
  retry = false;
  name = _SchemaError.name;
  constructor(opts) {
    super({
      ...opts
    });
  }
  static fromZod(e, raw, context) {
    return new _SchemaError({
      message: e.message,
      context: {
        raw: JSON.stringify(raw),
        ...context
      }
    });
  }
};

// src/errors/env-error.ts
var EnvError = class _EnvError extends BaseError {
  retry = false;
  name = _EnvError.name;
};

exports.BaseError = BaseError;
exports.EnvError = EnvError;
exports.Err = Err;
exports.FetchError = FetchError;
exports.Ok = Ok;
exports.SchemaError = SchemaError;
exports.wrap = wrap;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map