"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Unkey: () => Unkey,
  and: () => import_rbac.and,
  or: () => import_rbac.or,
  verifyKey: () => verifyKey
});
module.exports = __toCommonJS(src_exports);

// package.json
var version = "0.26.2";

// src/telemetry.ts
function getTelemetry(opts) {
  let platform;
  let runtime;
  const sdkVersions = [`@unkey/api@${version}`];
  try {
    if (typeof process !== "undefined") {
      if (process.env.UNKEY_DISABLE_TELEMETRY) {
        return null;
      }
      platform = process.env.VERCEL ? "vercel" : process.env.AWS_REGION ? "aws" : void 0;
      if (typeof EdgeRuntime !== "undefined") {
        runtime = "edge-light";
      } else {
        runtime = `node@${process.version}`;
      }
    }
    if (opts.wrapperSdkVersion) {
      sdkVersions.push(opts.wrapperSdkVersion);
    }
  } catch (_error) {
  }
  return { platform, runtime, sdkVersions };
}

// src/client.ts
var Unkey = class {
  baseUrl;
  rootKey;
  cache;
  telemetry;
  retry;
  constructor(opts) {
    this.baseUrl = opts.baseUrl ?? "https://api.unkey.dev";
    this.rootKey = opts.rootKey ?? opts.token;
    if (!opts.disableTelemetry) {
      this.telemetry = getTelemetry(opts);
    }
    this.cache = opts.cache;
    if (!this.rootKey) {
      throw new Error(
        "Unkey root key must be set, maybe you passed in `undefined` or an empty string?"
      );
    }
    this.retry = {
      attempts: opts.retry?.attempts ?? 5,
      backoff: opts.retry?.backoff ?? ((n) => Math.round(Math.exp(n) * 10))
    };
  }
  getHeaders() {
    const headers = {
      "Content-Type": "application/json",
      Authorization: `Bearer ${this.rootKey}`
    };
    if (this.telemetry?.sdkVersions) {
      headers["Unkey-Telemetry-SDK"] = this.telemetry.sdkVersions.join(",");
    }
    if (this.telemetry?.platform) {
      headers["Unkey-Telemetry-Platform"] = this.telemetry.platform;
    }
    if (this.telemetry?.runtime) {
      headers["Unkey-Telemetry-Runtime"] = this.telemetry.runtime;
    }
    return headers;
  }
  async fetch(req) {
    let res = null;
    let err = null;
    for (let i = 0; i <= this.retry.attempts; i++) {
      const url = new URL(`${this.baseUrl}/${req.path.join("/")}`);
      if (req.query) {
        for (const [k, v] of Object.entries(req.query)) {
          if (typeof v === "undefined" || v === null) {
            continue;
          }
          url.searchParams.set(k, v.toString());
        }
      }
      res = await fetch(url, {
        method: req.method,
        headers: this.getHeaders(),
        cache: this.cache,
        body: JSON.stringify(req.body)
      }).catch((e) => {
        err = e;
        return null;
      });
      if (res?.ok) {
        return { result: await res.json() };
      }
      const backoff = this.retry.backoff(i);
      console.debug(
        "attempt %d of %d to reach %s failed, retrying in %d ms: %s | %s",
        i + 1,
        this.retry.attempts + 1,
        url,
        backoff,
        // @ts-ignore I don't understand why `err` is `never`
        err?.message ?? `status=${res?.status}`,
        res?.headers.get("unkey-request-id")
      );
      await new Promise((r) => setTimeout(r, backoff));
    }
    if (res) {
      return { error: await res.json() };
    }
    return {
      error: {
        // @ts-ignore
        code: "FETCH_ERROR",
        // @ts-ignore I don't understand why `err` is `never`
        message: err?.message ?? "No response",
        docs: "https://developer.mozilla.org/en-US/docs/Web/API/fetch",
        requestId: "N/A"
      }
    };
  }
  get keys() {
    return {
      create: async (req) => {
        return await this.fetch({
          path: ["v1", "keys.createKey"],
          method: "POST",
          body: req
        });
      },
      update: async (req) => {
        return await this.fetch({
          path: ["v1", "keys.updateKey"],
          method: "POST",
          body: req
        });
      },
      verify: async (req) => {
        return await this.fetch({
          path: ["v1", "keys.verifyKey"],
          method: "POST",
          body: req
        });
      },
      delete: async (req) => {
        return await this.fetch({
          path: ["v1", "keys.deleteKey"],
          method: "POST",
          body: req
        });
      },
      updateRemaining: async (req) => {
        return await this.fetch({
          path: ["v1", "keys.updateRemaining"],
          method: "POST",
          body: req
        });
      },
      get: async (req) => {
        return await this.fetch({
          path: ["v1", "keys.getKey"],
          method: "GET",
          query: req
        });
      },
      getVerifications: async (req) => {
        return await this.fetch({
          path: ["v1", "keys.getVerifications"],
          method: "GET",
          query: req
        });
      }
    };
  }
  get apis() {
    return {
      create: async (req) => {
        return await this.fetch({
          path: ["v1", "apis.createApi"],
          method: "POST",
          body: req
        });
      },
      delete: async (req) => {
        return await this.fetch({
          path: ["v1", "apis.deleteApi"],
          method: "POST",
          body: req
        });
      },
      get: async (req) => {
        return await this.fetch({
          path: ["v1", "apis.getApi"],
          method: "GET",
          query: req
        });
      },
      listKeys: async (req) => {
        return await this.fetch({
          path: ["v1", "apis.listKeys"],
          method: "GET",
          query: req
        });
      }
    };
  }
  get ratelimits() {
    return {
      limit: async (req) => {
        return await this.fetch({
          path: ["v1", "ratelimits.limit"],
          method: "POST",
          body: req
        });
      }
    };
  }
  get identities() {
    return {
      create: async (req) => {
        return await this.fetch({
          path: ["v1", "identities.createIdentity"],
          method: "POST",
          body: req
        });
      },
      get: async (req) => {
        return await this.fetch({
          path: ["v1", "identities.getIdentity"],
          method: "GET",
          query: req
        });
      },
      list: async (req) => {
        return await this.fetch({
          path: ["v1", "identities.listIdentities"],
          method: "GET",
          query: req
        });
      },
      delete: async (req) => {
        return await this.fetch({
          path: ["v1", "identities.deleteIdentity"],
          method: "POST",
          body: req
        });
      },
      update: async (req) => {
        return await this.fetch({
          path: ["v1", "identities.updateIdentity"],
          method: "POST",
          body: req
        });
      }
    };
  }
  get migrations() {
    return {
      createKeys: async (req) => {
        return await this.fetch({
          path: ["v1", "migrations.createKeys"],
          method: "POST",
          body: req
        });
      },
      enqueueKeys: async (req) => {
        return await this.fetch({
          path: ["v1", "migrations.enqueueKeys"],
          method: "POST",
          body: req
        });
      }
    };
  }
};

// src/verify.ts
function verifyKey(req) {
  const unkey = new Unkey({ rootKey: "public" });
  return unkey.keys.verify(typeof req === "string" ? { key: req } : req);
}

// src/index.ts
var import_rbac = require("@unkey/rbac");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Unkey,
  and,
  or,
  verifyKey
});
//# sourceMappingURL=index.js.map